**鸽巢排序（Pigeonhole Sort）**

鸽巢排序（Pigeonhole Sort）是一种基于计数排序的排序算法，它用于排序整数值的数组，并且这些值都在一个已知的范围内。鸽巢排序的主要思想是将数组中的每个元素放到一个“鸽巢”中，然后再将这些鸽巢中的元素按顺序取出。

### 1. 算法概念

鸽巢排序的核心思想是：
1. **确定范围**: 预先知道数组中元素的值域（最小值和最大值）。
2. **分配到鸽巢**: 根据元素值将每个元素放到对应的鸽巢中。
3. **按顺序取出**: 按照鸽巢的顺序取出元素，形成排序后的数组。

### 2. 算法步骤

以下是鸽巢排序的详细步骤：

1. **找出范围**:
   - 找出数组中的最小值和最大值，以确定鸽巢的范围。
   
2. **创建鸽巢**:
   - 根据最小值和最大值，创建一个大小足够的鸽巢数组（通常是一个布尔数组或计数数组）。

3. **填充鸽巢**:
   - 遍历输入数组，对于每个元素，将其放入对应的鸽巢中。可以使用计数或标记来表示每个鸽巢中的元素。

4. **提取结果**:
   - 遍历鸽巢，将每个鸽巢中的元素按顺序提取到结果数组中。

### 3. 时间复杂度和空间复杂度

- **时间复杂度**:
  - **最坏情况**: $O(n + k)$，其中 $n$ 是数组的长度，$k$ 是鸽巢的数量（即最大值与最小值之差加一）。
  - **最佳情况**: $O(n + k)$，与最坏情况相同。
  - **平均情况**: $O(n + k)$，一般情况下时间复杂度为 $O(n + k)$。

- **空间复杂度**:
  - **空间复杂度**: $O(n + k)$，需要额外的鸽巢空间。

### 4. 代码示例

以下是使用 Go 语言实现的鸽巢排序算法的示例：

```go
package main

import "fmt"

// 鸽巢排序
func pigeonholeSort(arr []int) {
    if len(arr) == 0 {
        return
    }

    min := arr[0]
    max := arr[0]

    // 找到最小值和最大值
    for _, num := range arr {
        if num < min {
            min = num
        }
        if num > max {
            max = num
        }
    }

    // 创建鸽巢
    size := max - min + 1
    holes := make([]int, size)

    // 填充鸽巢
    for _, num := range arr {
        holes[num-min]++
    }

    // 提取结果
    index := 0
    for i, count := range holes {
        for count > 0 {
            arr[index] = i + min
            index++
            count--
        }
    }
}

func main() {
    arr := []int{8, 3, 2, 7, 4, 6, 5, 1}
    fmt.Println("Original array:", arr)
    pigeonholeSort(arr)
    fmt.Println("Sorted array:", arr)
}
```

### 5. 优缺点

**优点**:
- **适用于有限范围的整数**: 对于值域已知且范围不大的整数数组，鸽巢排序非常高效。
- **线性时间复杂度**: 在数据范围已知且合适的情况下，时间复杂度为 $O(n + k)$。

**缺点**:
- **空间复杂度高**: 需要额外的空间来存储鸽巢，尤其是在值域较大的情况下，可能需要大量内存。
- **仅适用于整数排序**: 适用于整数值的排序，对于其他类型的数据不适用。

### 总结

鸽巢排序是一种基于值域已知的排序算法，通过将元素分配到对应的鸽巢中来实现排序。它在值域范围较小且已知的情况下，具有线性时间复杂度和较高的效率。然而，其空间复杂度较高，并且只适用于整数值的排序。鸽巢排序在特定场景下可以提供高效的排序解决方案。