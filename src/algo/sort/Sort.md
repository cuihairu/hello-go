# 排序
排序算法是计算机科学中重要的课题，它们的效率和适用场景各不相同。以下是常见排序算法的对比，包括它们的时间复杂度、空间复杂度以及是否为稳定算法的描述。

### 1. 冒泡排序（Bubble Sort）

- **时间复杂度**:
  - 最坏情况: O(n²)
  - 平均情况: O(n²)
  - 最好情况: O(n)（当数组已经有序时）
- **空间复杂度**: O(1)（原地排序）
- **稳定性**: 稳定
- **描述**: 冒泡排序是一种简单的排序算法，通过重复遍历待排序的元素，比较相邻的元素并交换顺序错误的元素，将较大的元素“冒泡”到数组的末尾。由于其时间复杂度较高，通常不适用于大规模数据的排序。

### 2. 选择排序（Selection Sort）

- **时间复杂度**:
  - 最坏情况: O(n²)
  - 平均情况: O(n²)
  - 最好情况: O(n²)
- **空间复杂度**: O(1)（原地排序）
- **稳定性**: 不稳定
- **描述**: 选择排序通过不断选择未排序部分的最小（或最大）元素，并将其放到已排序部分的末尾。虽然实现简单，但其性能对数据规模的增长不够友好。

### 3. 插入排序（Insertion Sort）

- **时间复杂度**:
  - 最坏情况: O(n²)
  - 平均情况: O(n²)
  - 最好情况: O(n)（当数组已经有序时）
- **空间复杂度**: O(1)（原地排序）
- **稳定性**: 稳定
- **描述**: 插入排序通过构建一个有序的子序列，将每个新的元素插入到该子序列中的正确位置。适合于小规模数据和部分有序的数据排序。

### 4. 快速排序（Quick Sort）

- **时间复杂度**:
  - 最坏情况: O(n²)（当选择的基准元素导致极端不平衡时）
  - 平均情况: O(n log n)
  - 最好情况: O(n log n)
- **空间复杂度**: O(log n)（递归栈空间）
- **稳定性**: 不稳定
- **描述**: 快速排序采用分治策略，通过选择一个基准元素将数组分成两个子数组，并递归地排序子数组。它在大多数情况下表现良好，但在某些特定情况下可能会退化为较差的性能。

### 5. 归并排序（Merge Sort）

- **时间复杂度**:
  - 最坏情况: O(n log n)
  - 平均情况: O(n log n)
  - 最好情况: O(n log n)
- **空间复杂度**: O(n)（需要额外的空间来存储临时数组）
- **稳定性**: 稳定
- **描述**: 归并排序使用分治策略将数组分成两部分，分别排序这两部分，然后合并已排序的部分。它的时间复杂度较好，但需要额外的空间进行合并操作。

### 6. 堆排序（Heap Sort）

- **时间复杂度**:
  - 最坏情况: O(n log n)
  - 平均情况: O(n log n)
  - 最好情况: O(n log n)
- **空间复杂度**: O(1)（原地排序）
- **稳定性**: 不稳定
- **描述**: 堆排序基于堆数据结构，将待排序的数组构建成一个最大堆（或最小堆），然后逐步将堆顶元素移到数组的末尾。适合需要对数据进行原地排序的场景。

### 算法对比总结

| 排序算法      | 时间复杂度（最坏） | 时间复杂度（平均） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |
|---------------|--------------------|--------------------|--------------------|------------|--------|
| 冒泡排序      | O(n²)              | O(n²)              | O(n)               | O(1)       | 稳定   |
| 选择排序      | O(n²)              | O(n²)              | O(n²)              | O(1)       | 不稳定 |
| 插入排序      | O(n²)              | O(n²)              | O(n)               | O(1)       | 稳定   |
| 快速排序      | O(n²)              | O(n log n)         | O(n log n)         | O(log n)   | 不稳定 |
| 归并排序      | O(n log n)         | O(n log n)         | O(n log n)         | O(n)       | 稳定   |
| 堆排序        | O(n log n)         | O(n log n)         | O(n log n)         | O(1)       | 不稳定 |

这些排序算法各有优缺点，适合不同的应用场景。选择合适的排序算法需要考虑数据规模、内存限制和是否需要稳定性等因素。